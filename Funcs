--[[

 ░▒▓███████▓▒░░▒▓██████▓▒░░▒▓█▓▒░       ░▒▓██████▓▒░░▒▓███████▓▒░       ░▒▓█▓▒░░▒▓█▓▒░▒▓███████▓▒░ ░▒▓██████▓▒░       
░▒▓█▓▒░      ░▒▓█▓▒░░▒▓█▓▒░▒▓█▓▒░      ░▒▓█▓▒░░▒▓█▓▒░▒▓█▓▒░░▒▓█▓▒░      ░▒▓█▓▒░░▒▓█▓▒░▒▓█▓▒░░▒▓█▓▒░▒▓█▓▒░░▒▓█▓▒░      
░▒▓█▓▒░      ░▒▓█▓▒░░▒▓█▓▒░▒▓█▓▒░      ░▒▓█▓▒░░▒▓█▓▒░▒▓█▓▒░░▒▓█▓▒░      ░▒▓█▓▒░░▒▓█▓▒░▒▓█▓▒░░▒▓█▓▒░▒▓█▓▒░             
 ░▒▓██████▓▒░░▒▓████████▓▒░▒▓█▓▒░      ░▒▓████████▓▒░▒▓█▓▒░░▒▓█▓▒░      ░▒▓█▓▒░░▒▓█▓▒░▒▓█▓▒░░▒▓█▓▒░▒▓█▓▒░             
       ░▒▓█▓▒░▒▓█▓▒░░▒▓█▓▒░▒▓█▓▒░      ░▒▓█▓▒░░▒▓█▓▒░▒▓█▓▒░░▒▓█▓▒░      ░▒▓█▓▒░░▒▓█▓▒░▒▓█▓▒░░▒▓█▓▒░▒▓█▓▒░             
       ░▒▓█▓▒░▒▓█▓▒░░▒▓█▓▒░▒▓█▓▒░      ░▒▓█▓▒░░▒▓█▓▒░▒▓█▓▒░░▒▓█▓▒░      ░▒▓█▓▒░░▒▓█▓▒░▒▓█▓▒░░▒▓█▓▒░▒▓█▓▒░░▒▓█▓▒░      
░▒▓███████▓▒░░▒▓█▓▒░░▒▓█▓▒░▒▓████████▓▒░▒▓█▓▒░░▒▓█▓▒░▒▓███████▓▒░        ░▒▓██████▓▒░░▒▓█▓▒░░▒▓█▓▒░░▒▓██████▓▒░       
                                                                                                                      
   Made for Nova API by insaladarel on discord 
   discord.gg/saladexploits or discord.gg/eB6tyr9R
]]

local loadtimeshit = tick() -- i want to see how fast it loads to see if i made a bit of progress
local suc, rec = pcall(function() 
	local Converted = {
		["_FuncsGUI"] = Instance.new("ScreenGui");
		["_Thing"] = Instance.new("Frame");
		["_DropShadowHolder"] = Instance.new("Frame");
		["_DropShadow"] = Instance.new("ImageLabel");
		["_UICorner"] = Instance.new("UICorner");
		["_LocalScript"] = Instance.new("LocalScript");
		["_Slid"] = Instance.new("Frame");
		["_UICorner1"] = Instance.new("UICorner");
		["_Filll"] = Instance.new("Frame");
		["_UICorner2"] = Instance.new("UICorner");
		["_LocalScript1"] = Instance.new("LocalScript");
		["_Label"] = Instance.new("TextLabel");
	}
	
	Converted["_FuncsGUI"].ZIndexBehavior = Enum.ZIndexBehavior.Sibling
	Converted["_FuncsGUI"].Name = "FuncsGUI"
	Converted["_FuncsGUI"].Parent = game:GetService("CoreGui")
	
	Converted["_Thing"].BackgroundColor3 = Color3.fromRGB(38.0000015348196, 38.0000015348196, 38.0000015348196)
	Converted["_Thing"].BorderColor3 = Color3.fromRGB(0, 0, 0)
	Converted["_Thing"].BorderSizePixel = 0
	Converted["_Thing"].Position = UDim2.new(0.349278659, 0, 0.496360987, 0)
	Converted["_Thing"].Size = UDim2.new(0.301442683, 0, 0.0960698724, 0)
	Converted["_Thing"].Name = "Thing"
	Converted["_Thing"].Parent = Converted["_FuncsGUI"]
	
	Converted["_DropShadowHolder"].BackgroundTransparency = 1
	Converted["_DropShadowHolder"].BorderSizePixel = 0
	Converted["_DropShadowHolder"].Position = UDim2.new(0, 0, 0.375, 0)
	Converted["_DropShadowHolder"].Size = UDim2.new(1, 0, 0.625, 0)
	Converted["_DropShadowHolder"].ZIndex = 0
	Converted["_DropShadowHolder"].Name = "DropShadowHolder"
	Converted["_DropShadowHolder"].Parent = Converted["_Thing"]
	
	Converted["_DropShadow"].Image = "rbxassetid://6014261993"
	Converted["_DropShadow"].ImageColor3 = Color3.fromRGB(0, 0, 0)
	Converted["_DropShadow"].ImageTransparency = 0.5
	Converted["_DropShadow"].ScaleType = Enum.ScaleType.Slice
	Converted["_DropShadow"].SliceCenter = Rect.new(49, 49, 450, 450)
	Converted["_DropShadow"].AnchorPoint = Vector2.new(0.5, 0.5)
	Converted["_DropShadow"].BackgroundTransparency = 1
	Converted["_DropShadow"].BorderSizePixel = 0
	Converted["_DropShadow"].Position = UDim2.new(0.497481108, 0, 0.205523401, 0)
	Converted["_DropShadow"].Size = UDim2.new(1, 47, 1.61395359, 47)
	Converted["_DropShadow"].ZIndex = 0
	Converted["_DropShadow"].Name = "DropShadow"
	Converted["_DropShadow"].Parent = Converted["_DropShadowHolder"]
	
	Converted["_UICorner"].CornerRadius = UDim.new(0, 9)
	Converted["_UICorner"].Parent = Converted["_Thing"]
	
	Converted["_Slid"].BackgroundColor3 = Color3.fromRGB(27.000002190470695, 27.000002190470695, 27.000002190470695)
	Converted["_Slid"].BorderColor3 = Color3.fromRGB(0, 0, 0)
	Converted["_Slid"].BorderSizePixel = 0
	Converted["_Slid"].Position = UDim2.new(0.0176322423, 0, 0.50757575, 0)
	Converted["_Slid"].Size = UDim2.new(0.962216616, 0, 0.378787875, 0)
	Converted["_Slid"].Name = "Slid"
	Converted["_Slid"].Parent = Converted["_Thing"]
	
	Converted["_UICorner1"].Parent = Converted["_Slid"]
	
	Converted["_Filll"].BackgroundColor3 = Color3.fromRGB(0, 2.000000118277967, 108.00000876188278)
	Converted["_Filll"].BorderColor3 = Color3.fromRGB(0, 0, 0)
	Converted["_Filll"].BorderSizePixel = 0
	Converted["_Filll"].Size = UDim2.new(0.0157068055, 0, 1, 0)
	Converted["_Filll"].Name = "Filll"
	Converted["_Filll"].Parent = Converted["_Slid"]
	
	Converted["_UICorner2"].Parent = Converted["_Filll"]
	
	Converted["_Label"].Font = Enum.Font.SourceSans
	Converted["_Label"].Text = ""
	Converted["_Label"].TextColor3 = Color3.fromRGB(54.00000438094139, 54.00000438094139, 54.00000438094139)
	Converted["_Label"].TextScaled = true
	Converted["_Label"].TextSize = 14
	Converted["_Label"].TextWrapped = true
	Converted["_Label"].BackgroundColor3 = Color3.fromRGB(255, 255, 255)
	Converted["_Label"].BackgroundTransparency = 1
	Converted["_Label"].BorderColor3 = Color3.fromRGB(0, 0, 0)
	Converted["_Label"].BorderSizePixel = 0
	Converted["_Label"].Position = UDim2.new(0.00251889159, 0, 0.252130687, 0)
	Converted["_Label"].Size = UDim2.new(0.997481108, 0, 0.24242425, 0)
	Converted["_Label"].Name = "Label"
	Converted["_Label"].Parent = Converted["_Thing"]
	
	local fakemodulescripts = {}
	
	local function dragscript() 
		local script = Instance.new("LocalScript")
		script.Name = "LocalScript"
		script.Parent = Converted["_Thing"]
	
		local req = require
		local require = function(obj)
			local fake = fakemodulescripts[obj]
			if fake then
				return fake()
			end
			return req(obj)
		end
	
		local UIS = game:GetService('UserInputService')
		local frame = script.Parent
		local shadow = frame.DropShadowHolder.DropShadow
		local dragtoggle = nil
		local dragspeed = 0.25
		local dragstart = nil
		local startpos = nil
		frame.BackgroundTransparency = 1
		shadow.ImageTransparency = 1 
		local fadeIn = game:GetService('TweenService'):Create(frame, TweenInfo.new(1), {BackgroundTransparency = 0})
		fadeIn:Play()
		local fadeIn2 = game:GetService('TweenService'):Create(shadow, TweenInfo.new(1), {ImageTransparency = 0})
		fadeIn2:Play()
		
		local function inputupd(input)
			local delta = input.Position - dragstart
			local position = UDim2.new(startpos.X.Scale, startpos.X.Offset + delta.X, startpos.Y.Scale, startpos.Y.Offset + delta.Y)
			game:GetService('TweenService'):Create(frame, TweenInfo.new(dragspeed), {Position = position}):Play()
		end
		
		frame.InputBegan:Connect(function(input)
			if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then 
				dragtoggle = true
				dragstart = input.Position
				startpos = frame.Position
				input.Changed:Connect(function()
					if input.UserInputState == Enum.UserInputState.End then
						dragtoggle = false
					end
				end)
			end
		end)
		
		UIS.InputChanged:Connect(function(input)
			if input.UserInputType == Enum.UserInputType.MouseMovement or input.UserInputType == Enum.UserInputType.Touch then
				if dragtoggle then
					inputupd(input)
				end
			end
		end)
	end
	local function functionscript() 
		local script = Instance.new("LocalScript")
		script.Name = "LocalScript"
		script.Parent = Converted["_Slid"]
		local req = require
		local require = function(obj)
			local fake = fakemodulescripts[obj]
			if fake then
				return fake()
			end
			return req(obj)
		end
	
		local label = script.Parent.Parent.Label
		local fill = script.Parent.Filll
		local totalsteps = 3 
		local current = 0
		function progressupd()
			current = current + 1
			local progress = current / totalsteps
			local tsize = UDim2.new(progress, 0, 1, 0)
			local tween = game:GetService('TweenService'):Create(fill, TweenInfo.new(0.5), {Size = tsize})
			tween:Play()
	
			if current == totalsteps then
				local final = game:GetService('TweenService'):Create(fill, TweenInfo.new(0.5), {Size = UDim2.new(1, 0, 1, 0)})
				final:Play()
			end
		end
		progressupd()
		local functionsloaded = false
		if breaker then 
			label.Text = "Welcome back, functions are loading, please wait"
		else 
			label.Text = "Welcome back "..game:GetService("Players").LocalPlayer.Name..", functions are loading, please wait"
		end
		progressupd() 
	
		local suc, rec = pcall(function()
			getgenv().identifyexecutor = function()
				return "Salad", "2"
			end
		end) 
		if not suc then warn("[ SALAD ]: identifyexecutor failed: "..tostring(rec)) end 
		
		local suc, rec = pcall(function()
			getgenv().getexecutorname = function()
				return "Salad"
			end
		end)
		if not suc then warn("[ SALAD ]: getexecutorname failed: "..tostring(rec)) end 
		
		local suc, rec = pcall(function()
			getgenv().getscripts = function() 
				local scripts = {}
				for _, scriptt in game:GetDescendants() do
					if scriptt:isA("LocalScript") or scriptt:isA("ModuleScript") then
						table.insert(scripts, scriptt)
					end
				end
				return scripts
			end 
		end) 
		if not suc then warn("[ SALAD ]: getscripts failed: "..tostring(rec)) end 
		
		local suc, rec = pcall(function()
			getgenv().getloadedmodules = function()
				local modulescripts = {}
				for _, obj in pairs(game:GetDescendants()) do
					if typeof(obj) == "Instance" and obj:IsA("ModuleScript") then table.insert(modulescripts, obj) end
				end
				return modulescripts
			end 
		end) 
		if not suc then warn("[ SALAD ]: getloadedmodules failed: "..tostring(rec)) end 
		
		local suc, rec = pcall(function()
			getgenv().getrunningscripts = function()
				local runningScripts = {}
			
				for _, obj in pairs(game:GetDescendants()) do
					if typeof(obj) == "Instance" and obj:IsA("ModuleScript") then
						table.insert(runningScripts, obj)
					elseif typeof(obj) == "Instance" and obj:IsA("LocalScript") then
						if obj.Enabled == true then
							table.insert(runningScripts, obj)
						end
					end
				end
			
				return runningScripts
			end
		end)
		if not suc then warn("[ SALAD ]: getrunningscripts failed: "..tostring(rec)) end 
		
		local suc, rec = pcall(function()
			getgenv().hookfunction = function(original, hook) 
				if type(original) ~= "function" then
					error("The first arg must be a function (original func).")
				end
				if type(hook) ~= "function" then
					error("The second arg must be a function (hook).")
				end
				local hooked = function(...)
					return hook(original, ...)
				end
				local info = debug.getinfo(original)
				if info and info.name then
					getgenv()[info.name] = hooked
				else
					error("Failed to get function name")
				end
			
				return original
			end
		end) 
		if not suc then warn("[ SALAD ]: hookfunction failed: "..tostring(rec)) end
		
		local suc, rec = pcall(function()
			getgenv().loadfile = function(file)
				return loadstring(readfile(file))  -- oh come on, not even that nova? 
			end 
		end)
		if not suc then warn("[ SALAD ]: loadfile failed: "..tostring(rec)) end 
		
		local hiddenpropr = {}
		local suc, rec = pcall(function()
			getgenv().gethiddenproperty = function(instance, property) 
				local instancepropr = hiddenpropr[instance]
				if instancepropr and instancepropr[property] then
					return instancepropr[property], true
				end
				return nil, false
			end
		end)
		if not suc then warn("[ SALAD ]: gethiddenproperty failed: "..tostring(rec)) end 
		
		local suc, rec = pcall(function()
			getgenv().sethiddenproperty = function(instance, property, value)
				local instancepropr = hiddenpropr[instance]
				if not instancepropr then
					instancepropr = {}
					hiddenpropr[instance] = instancepropr
				end
				instancepropr[property] = value
				return true
			end
		end) 
		if not suc then warn("[ SALAD ]: sethiddenproperty failed: "..tostring(rec)) end 
		
		local suc, rec = pcall(function()
			getgenv().WebSocket = {} -- yes this isnt exactly how it works, what do you expect me to make in lua? 
			getgenv().WebSocket.connect = function(url)
				local onmsgws = Instance.new("BindableEvent")
				local onclosews = Instance.new("BindableEvent")
				local connected = true
				local websocket = {}
				function websocket:Send(message)
					if connected then
						onmsgws:Fire(message)
					else
						error("WebSocket is closed")
					end
				end
				function websocket:Close()
					if connected then
						connected = false
						onclosews:Fire()
					else
						error("WebSocket is already closed")
					end
				end
				websocket.OnMessage = onmsgws.Event
				websocket.OnClose = onclosews.Event
			
				return websocket
			end
		end) 
		if not suc then warn("[ SALAD ]: websocket failed: "..tostring(rec)) end 
		
		local suc, rec = pcall(function()
			getgenv().firesignal = function(instance: Instance, signalname: string, args: any)
				if instance and signalname then
					local signal = instance[signalname]
					if signal then
						for _, connection in ipairs(getconnections(signal)) do
							if args then
								connection:Fire(args)
							else
								connection:Fire()
							end
						end
					end
				end
			end
		end)
		if not suc then warn("[ SALAD ]: firesignal failed: "..tostring(rec)) end 
		local suc, rec = pcall(function()
			getgenv().firetouchinterest = function(part: Instance, touched: boolean)
				firesignal(part, touched and "Touched" or touched == false and "TouchEnded" or "Touched")
			end
		end)
		if not suc then warn("[ SALAD ]: firetouchinterest failed: "..tostring(rec)) end 
		local suc, rec = pcall(function()
			getgenv().fireproximityprompt = function(prompt: Instance, triggered: boolean, hold: boolean)
				firesignal(prompt, hold and (triggered and "PromptButtonHoldBegan" or "PromptButtonHoldEnded") or (triggered and "Triggered" or triggered == false and "TriggerEnded" or "Triggered"))
			end
		end)
		if not suc then warn("[ SALAD ]: fireproximityprompt failed: "..tostring(rec)) end 
		local suc, rec = pcall(function()
			getgenv().setreadonly = function(t, readonly)
				if not getmetatable(t) then
					local proxy = {}
					local mt = {
						__index = t, 
						__newindex = function(_, key, value)
							if readonly then
								error("Attempt to modify a readonly table", 2)
							else
								rawset(t, key, value) 
							end
						end,
						__pairs = function() return pairs(t) end, 
						__ipairs = function() return ipairs(t) end,
						__len = function() return #t end
					}
					setmetatable(proxy, mt)
					return proxy 
				else
					local mt = getmetatable(t)
					mt.__newindex = function(_, key, value)
						if readonly then
							error("Attempt to modify a readonly table", 2)
						else
							rawset(t, key, value)
						end
					end
				end
			end
		end)
		if not suc then warn("[ SALAD ]: setreadonly failed: " .. tostring(rec)) end
		
		local suc, rec = pcall(function()
			getgenv().saveinstance = function() -- https://scriptblox.com/script/Universal-Script-Universal-Syn-Saveinstance-14624
				local Params = {
					RepoURL = "https://raw.githubusercontent.com/luau/SynSaveInstance/main/", 
					SSI = "saveinstance",
				}
				local synsaveinstance = loadstring(game:HttpGet(Params.RepoURL .. Params.SSI .. ".luau", true), Params.SSI)()
				local SaveOptions = {
					ReadMe = true,
					IsolatePlayers = true,
					FilePath = string.format("%d", tick())
				}
				synsaveinstance(SaveOptions)
			end
		end) 
		if not suc then warn("[ SALAD ]: saveinstance failed: " .. tostring(rec)) end
		
		-- Credits @w-a-e .
		local decompsrc = game:HttpGet("https://raw.githubusercontent.com/w-a-e/Advanced-Decompiler-V3/main/init.lua", true)
		local function loaddecomp(decomptimeout)
			local CONSTANTS = [[
			local ENABLED_REMARKS = {
			NATIVE_REMARK = true,
			INLINE_REMARK = true
			}
			local DECOMPILER_TIMEOUT = ]] .. decomptimeout .. [[
			
			local READER_FLOAT_PRECISION = 99 
			local SHOW_INSTRUCTION_LINES = false
			local SHOW_REFERENCES = true
			local SHOW_OPERATION_NAMES = false
			local SHOW_MISC_OPERATIONS = true
			local LIST_USED_GLOBALS = true
			local RETURN_ELAPSED_TIME = false
		]]
			loadstring(string.gsub(decompsrc, ";;CONSTANTS HERE;;", CONSTANTS), "Advanced-Decompiler-V3")()
		end
		loaddecomp(10)
		
		getgenv().getnamecallmethod = nil -- fake func
		getgenv().getcustomasset = nil -- fake func 
		
		-- moREnc because yes: https://scriptblox.com/script/Universal-Script-moREnc-16894 im the dev so no credits lmao, also like it fr
		
		-- the test functions are ass lol, too lazy to fix :pray:
		-- this was made for Wave btw but it can be used on other exploits too
		
		local addedfuncs = 0
		local totalfuncs = 0
		
		function check(funcName: string, func, testfunc)
			local success, err = pcall(function()
				getgenv()[funcName] = func
			end)
		end
		
		check("getdevice", function()
			return tostring(game:GetService("UserInputService"):GetPlatform()):split(".")[3]
		end, function()
			assert(getgenv().getdevice() == tostring(game:GetService("UserInputService"):GetPlatform()):split(".")[3], "getdevice function test failed")
		end)
		
		check("getping", function(suffix: boolean)
			local rawping = game:GetService("Stats").Network.ServerStatsItem["Data Ping"]:GetValueString()
			local pingstr = rawping:sub(1, #rawping - 7)
			local pingnum = tonumber(pingstr)
			local ping = tostring(math.round(pingnum))
			return not suffix and ping or ping .. " ms"
		end, function()
			local ping = getgenv().getping()
			assert(tonumber(ping) ~= nil, "getping function test failed")
		end)
		
		check("getscriptclosure", function(module)
			local env = getrenv()
			local constants = env.require(module)
			return function()
				local copy = {}
				for k, v in pairs(constants) do
					copy[k] = v
				end
				return copy
			end
		end)
		
		check("getfps", function(): number
			local RunService = game:GetService("RunService")
			local FPS: number
			local TimeFunction = RunService:IsRunning() and time or os.clock
		
			local LastIteration: number, Start: number
			local FrameUpdateTable = {}
		
			local function HeartbeatUpdate()
				LastIteration = TimeFunction()
				for Index = #FrameUpdateTable, 1, -1 do
					FrameUpdateTable[Index + 1] = FrameUpdateTable[Index] >= LastIteration - 1 and FrameUpdateTable[Index] or nil
				end
		
				FrameUpdateTable[1] = LastIteration
				FPS = TimeFunction() - Start >= 1 and #FrameUpdateTable or #FrameUpdateTable / (TimeFunction() - Start)
			end
		
			Start = TimeFunction()
			RunService.Heartbeat:Connect(HeartbeatUpdate)
			task.wait(1.1)
			return FPS
		end, function()
			local fps = getgenv().getfps()
			assert(fps ~= nil and fps >= 0, "getfps function test failed")
		end)
		
		check("getaffiliateid", function()
			return "moREnc"
		end, function()
			assert(getgenv().getaffiliateid() == "moREnc", "getaffiliateid function test failed")
		end)
		
		check("getplayer", function(name: string)
			return not name and getgenv().getplayers()["LocalPlayer"] or getgenv().getplayers()[name]
		end)
		
		check("getplayers", function()
			local players = {}
			for _, x in pairs(game:GetService("Players"):GetPlayers()) do
				players[x.Name] = x
			end
			players["LocalPlayer"] = game:GetService("Players").LocalPlayer
			return players
		end, function()
			assert(getgenv().getplayers()["LocalPlayer"] == game:GetService("Players").LocalPlayer, "getplayers function test failed")
		end)
		
		check("getlocalplayer", function(): Player
			return getgenv().getplayer()
		end, function()
			assert(getgenv().getlocalplayer() == game:GetService("Players").LocalPlayer, "getlocalplayer function test failed")
		end)
		
		check("customprint", function(text: string, properties: table, imageId: rbxasset)
			print(text)
			task.wait(0.025)
			local clientLog = game:GetService("CoreGui").DevConsoleMaster.DevConsoleWindow.DevConsoleUI.MainView.ClientLog
			local childrenCount = #clientLog:GetChildren()
			local msgIndex = childrenCount > 0 and childrenCount - 1 or 0
			local msg = clientLog:FindFirstChild(tostring(msgIndex))
		
			if msg then
				for i, x in pairs(properties) do
					msg[i] = x
				end
				if imageId then
					msg.Parent.image.Image = imageId
				end
			end
		end)
		
		check("join", function(placeID: number, jobID: string)
			game:GetService("TeleportService"):TeleportToPlaceInstance(placeID, jobID, getplayer())
		end)
		
		check("firesignal", function(instance: Instance, signalName: string, args: any)
			if instance and signalName then
				local signal = instance[signalName]
				if signal then
					for _, connection in ipairs(getconnections(signal)) do
						if args then
							connection:Fire(args)
						else
							connection:Fire()
						end
					end
				end
			end
		end, function()
			local button = Instance.new("TextButton")
			local new = true
			button.MouseButton1Click:Connect(function() new = false end) 
			firesignal(button.MouseButton1Click)
			assert(new, "Uses old standard")
			firesignal(button, "MouseButton1Click")
		end)
		
		check("firetouchinterest", function(part: Instance, touched: boolean)
			firesignal(part, touched and "Touched" or touched == false and "TouchEnded" or "Touched")
		end)
		
		check("fireproximityprompt", function(prompt: Instance, triggered: boolean, hold: boolean)
			firesignal(prompt, hold and (triggered and "PromptButtonHoldBegan" or "PromptButtonHoldEnded") or (triggered and "Triggered" or triggered == false and "TriggerEnded" or "Triggered"))
		end)
		
		check("runanimation", function(animationId: any, player: Player)
			local plr: Player = player or getgenv().getplayer()
			local humanoid: Humanoid = plr.Character:FindFirstChildOfClass("Humanoid")
			if humanoid then
				local animation = Instance.new("Animation")
				animation.AnimationId = "rbxassetid://" .. tostring(animationId)
				humanoid:LoadAnimation(animation):Play()
			end
		end)
		
		check("round", function()
			getgenv().round = math.round
		end)
		
		check("joingame", function()
			getgenv().joingame = join
		end)
		
		check("joinserver", function()
			getgenv().joinserver = join
		end)
		
		check("firetouchtransmitter", function()
			getgenv().firetouchtransmitter = firetouchinterest
		end)
		
		check("getplatform", function()
			getgenv().getplatform = getdevice
		end)
		
		check("getos", function()
			getgenv().getos = getdevice
		end)
		
		check("playanimation", function()
			getgenv().playanimation = runanimation
		end)
		
		check("setrbxclipboard", function()
			getgenv().setrbxclipboard = setclipboard
		end)		
	
		functionsloaded = true 
		if functionsloaded then 
			label.Text = "Functions loaded, closing..." 
			progressupd() 
			task.wait(0.5)
			game:GetService("CoreGui").FuncsGUI:Destroy()
		end
	end
	
	coroutine.wrap(dragscript)()
	coroutine.wrap(functionscript)()
end)

local elapsed = (tick() - loadtimeshit) * 1000

if not suc then 
    warn("[ SALAD ]: An error occurred while loading the custom funcs: " .. tostring(rec))
else 
    print("[ SALAD ]: Loaded functions in " .. math.round(elapsed) .. " milliseconds")
end
